{"id":745429548,"lang":"java","time":"1 month, 1 week","timestamp":1657651690,"status_display":"Accepted","runtime":"288 ms","url":"/submissions/detail/745429548/","is_pending":"Not Pending","title":"Matchsticks to Square","memory":"72 MB","code":"/*\nclass Solution {\n    int[] ms;\n    int n;\n    //ban 817\n    public boolean makesquare(int[] matchsticks) {\n        ms = new int[16];\n        int k = 4;\n        int sum=0;\n        for(int i=0;i<matchsticks.length;++i)   sum += matchsticks[i];\n        if(sum%4 != 0)  return false;\n        int subsum = sum/4, num = n-1, curr = matchsticks[num];\n        n = matchsticks.length;\n        ms[num] = 1;\n        return check(matchsticks, subsum, num, curr, k);\n    }\n    boolean check(int[] matchsticks, int subsum, int num, int curr, int k){\n        if(k==1)    return true;\n        if(curr == subsum)  return check(matchsticks, subsum, n-1, 0, k-1);\n        for(int i= num;i>=0;--i){\n            if(ms[i] > subsum || (curr + matchsticks[i]) > subsum)  continue;\n            ms[i] = 1;\n            curr += matchsticks[i];\n            if(check(matchsticks, subsum, i+1, curr, k))    return true;\n            ms[i] = 0;\n            curr -= matchsticks[i];\n        }\n        return false;\n    }\n}\n*/\nclass Solution {\n\n    // The memoization cache to be used during recursion.\n    public HashMap<Pair<Integer, Integer>, Boolean> memo;\n\n    // Array containing our matchsticks.\n    public int[] nums;\n\n    // Possible side of our square depending on the total sum of all the matchsticks. \n    public int possibleSquareSide;\n\n    // Default constructor to initialise our memo cache.\n    public Solution() {\n        this.memo = new HashMap<Pair<Integer, Integer>, Boolean>();\n    }\n\n    // Main DP function.\n    public boolean recurse(Integer mask, Integer sidesDone) {\n        int total = 0;\n        int L = this.nums.length;\n\n        // The memo key for this recursion\n        Pair<Integer, Integer> memoKey = new Pair(mask, sidesDone);\n\n        // Find out the sum of matchsticks used till now.\n        for(int i = L - 1; i >= 0; i--) {\n            if ((mask&(1 << i)) == 0) {\n                total += this.nums[L - 1 - i];\n            }\n        }\n        if (total > 0 && total % this.possibleSquareSide == 0) {\n            sidesDone++;\n        }\n        if (sidesDone == 3) {\n            return true;\n        }\n        if (this.memo.containsKey(memoKey)) {\n            return this.memo.get(memoKey);\n        }\n        boolean ans = false;\n        int c = total / this.possibleSquareSide;\n        int rem = this.possibleSquareSide * (c + 1) - total;\n        for(int i = L - 1; i >= 0; i--) {\n            if (this.nums[L - 1 - i] <= rem && (mask&(1 << i)) > 0) {\n                if (this.recurse(mask ^ (1 << i), sidesDone)) {\n                    ans = true;\n                    break;\n                }\n            }\n        }\n        this.memo.put(memoKey, ans);\n        return ans;\n    }\n\n    public boolean makesquare(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n\n        int possibleSquareSide =  perimeter / 4;\n        if (possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n        this.nums = nums;\n        this.possibleSquareSide = possibleSquareSide;\n        return this.recurse((1 << L) - 1, 0);\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"matchsticks-to-square"}